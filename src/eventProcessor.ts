import dotenv from 'dotenv';

import { output, writeJsonStats } from './utils';
import { coloniesSet } from './trackColonies';
import networkClient from './networkClient';
import { colonySpecificEventsListener } from './eventListener';
import { getChainId } from './provider';
import { query, mutate } from './amplifyClient';
import { ContractEventsSignatures, ContractEvent } from './types';

dotenv.config();

/*
 * Here's where you'll be handling all your custom logic for the various events
 * this ingestors listens for, and which make their way into the Event Queue
 *
 * Here's an example of how to set up your case:
 *
 * case ContractEventsSignatures.<YourEventName>: {
 *   // your custom logic
 *   return;
 * }
 */
export default async (event: ContractEvent): Promise<void> => {
  if (!event.signature) {
    throw new Error('Event does not have a signature. Possibly bad event data. Refusing the process!');
  }

  switch (event.signature) {
    /*
     * New Colony Added
     */
    case ContractEventsSignatures.ColonyAdded: {
      const { colonyAddress, token: tokenAddress } = event?.args ?? {};

      /*
       * Add it to the Set
       */
      coloniesSet.add(JSON.stringify({ colonyAddress, tokenAddress }));
      await writeJsonStats({ trackedColonies: coloniesSet.size });

      output('Found new Colony:', colonyAddress, 'Total tracked colonies:', coloniesSet.size);

      /*
       * Setup all Colony specific listeners for it
       */
      await colonySpecificEventsListener(colonyAddress);
      return;
    }

    /*
     * New ERC-20 transfers
     * (but not Native Chain Token -- 0x0000...0000)
     */
    case ContractEventsSignatures.Transfer: {
      const { contractAddress, transactionHash, logIndex, blockNumber } = event ?? {};
      const chainId = getChainId();
      /*
       * @NOTE Take the values from the "array" rather than from the named properties
       * This is because our native tokens differ in abi from ERC20 or SAI tokens
       *
       * Here's the mapping:
       *
       * Ours   ERC20
       * ---    ---
       * src    from
       * dest   to
       * wad    value
       *
       * But if we take the values from the array, they will always be in the
       * same order: 0->from, 1->to, 2->value
       *
       * This way we can always be sure that get the correct values for the various
       * tokens all the time
       */
      const [source, dst, wad] = event?.args ?? {};

      /*
       * Determine if this transfer was generated by the reputation mining cycle
       * If that's the case, we need to filter it out.
       */
      const isMiningCycleTransfer = source === networkClient.address && wad.isZero();

      if (!isMiningCycleTransfer) {
        let existingClaim;
        const amount = wad.toString();
        const clamId = `${chainId}_${transactionHash}_${logIndex}`;
        /*
         * @NOTE That this check is only required for local development where
         * the chain does not mine a new block automatically, so you'll most likely
         * run parsing / events listener on the same block over and over
         * So as to not mess up your data / database, only create the event
         * if it does not exist
         */

        if (process.env.NODE_ENV !== 'production') {
          const { id: existingClaimId } = await query('getColonyUnclaimedFund', { clamId });
          existingClaim = existingClaimId;
        }

        output(
          'Found new Transfer of:', amount, 'into Colony:', dst,
          existingClaim || amount === '0'
            ? `but not acting upon it since ${existingClaim ? 'it already exists in the database' : ''}${amount === '0' ? 'it\'s value is zero' : ''}`
            : '',
        );

        // Don't add zero transfer claims in the database
        if (!existingClaim && amount !== '0') {
          await mutate('createColonyFundsClaim', {
            input: {
              id: clamId,
              colonyFundsClaimsId: dst,
              colonyFundsClaimTokenId: contractAddress,
              createdAtBlock: blockNumber,
              amount,
            },
          });
        }
      }
      return;
    }

    /*
     * New Colony transfer claims
     */
    case ContractEventsSignatures.ColonyFundsClaimed: {
      const { contractAddress: colonyAddress, blockNumber } = event ?? {};
      const { token: tokenAddress } = event?.args ?? {};

      const { items: unclaimedFunds } = await query(
        'getColonyUnclaimedFunds', {
          colonyAddress,
          upToBlock: blockNumber,
        },
      );

      /*
       * This check is actually required since anybody can make payout claims
       * for any colony, any time, even if there's nothing left to claim
       * (basically do claims for 0)
       */
      const colonyHasUnclaimedFunds = unclaimedFunds?.length;

      output(
        'Found new Transfer Claim for Token:', tokenAddress, 'by Colony:', colonyAddress,
        !colonyHasUnclaimedFunds
          ? 'but not acting upon it since all existing non-zero transactions were claimed for this token'
          : '',
      );

      /*
       * Colony needs to exist (this should not happen, but a safety check nontheless)
       * and to have unclaimed transactions for this token
       */
      if (colonyHasUnclaimedFunds) {
        await Promise.all(
          unclaimedFunds.map(
            async ({ id }: { id: string }) => await mutate(
              'deleteColonyFundsClaim', { input: { id } },
            ),
          ),
        );
      }

      return;
    }

    default: {
      return;
    };
  }
};
