import { query } from '~amplifyClient';
import networkClient from '~networkClient';
import { getChainId } from '~provider';
import { ContractEvent } from '~types';
import {
  GetColonyUnclaimedFundDocument,
  GetColonyUnclaimedFundQuery,
  GetColonyUnclaimedFundQueryVariables,
  GetTokenFromEverywhereDocument,
  GetTokenFromEverywhereQuery,
  GetTokenFromEverywhereQueryVariables,
} from '~graphql';
import { output, createFundsClaim } from '~utils';

export default async (event: ContractEvent): Promise<void> => {
  const { contractAddress: tokenAddress, logIndex, transactionHash } = event;
  const chainId = getChainId();
  /*
   * @NOTE Take the values from the "array" rather than from the named properties
   * This is because our native tokens differ in abi from ERC20 or SAI tokens
   *
   * Here's the mapping:
   *
   * Ours   ERC20
   * ---    ---
   * src    from
   * dest   to
   * wad    value
   *
   * But if we take the values from the array, they will always be in the
   * same order: 0->from, 1->to, 2->value
   *
   * This way we can always be sure that get the correct values for the various
   * tokens all the time
   */
  const [source, dst, wad] = event.args;

  /*
   * Determine if this transfer was generated by the reputation mining cycle
   * If that's the case, we need to filter it out.
   */
  const isMiningCycleTransfer =
    source === networkClient.address && wad.isZero();

  if (!isMiningCycleTransfer) {
    let existingClaim;
    const amount = wad.toString();
    const claimId = `${chainId}_${transactionHash}_${logIndex}`;
    /*
     * @NOTE That this check is only required for local development where
     * the chain does not mine a new block automatically, so you'll most likely
     * run parsing / events listener on the same block over and over
     * So as to not mess up your data / database, only create the event
     * if it does not exist
     *
     * @TODO an idea of how to reduce queries is to wrap this in a try catch block
     * and just send out the mutation
     * If it succeeds, great, the event is created, if it fails, assume the event
     * already existed in the database
     */

    if (process.env.NODE_ENV !== 'production') {
      const { id: existingClaimId } =
        (
          await query<
            GetColonyUnclaimedFundQuery,
            GetColonyUnclaimedFundQueryVariables
          >(GetColonyUnclaimedFundDocument, { claimId })
        )?.data?.getColonyFundsClaim ?? {};
      existingClaim = existingClaimId;
    }

    output(
      'Found new Transfer of:',
      amount,
      'into Colony:',
      dst,
      !!existingClaim || amount === '0'
        ? `but not acting upon it since ${
            existingClaim ? 'it already exists in the database' : ''
          }${amount === '0' ? "it's value is zero" : ''}`
        : '',
    );

    /**
     * Call the GetTokenFromEverywhere query to ensure the token
     * gets added to the DB if it doesn't already exist
     */
    const { data } =
      (await query<
        GetTokenFromEverywhereQuery,
        GetTokenFromEverywhereQueryVariables
      >(GetTokenFromEverywhereDocument, {
        input: {
          tokenAddress,
        },
      })) ?? {};

    const response = data?.getTokenFromEverywhere;
    if (!response?.items?.length) {
      output(
        `Token ${tokenAddress} not found in the database while handling Transfer event to colony ${dst}`,
      );
    }

    // Don't add zero transfer claims in the database
    if (!existingClaim && amount !== '0') {
      createFundsClaim({
        colonyAddress: dst,
        tokenAddress,
        amount,
        event,
      });
    }
  }
};
